{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DocStrands","text":"<p>When documenting your functions, you might find yourself documenting the same parameters over and over again. DocStrands provides a framework for re-using docstring information.</p>"},{"location":"#example","title":"Example","text":"<p>Imagine you\u2019re writing an HTTP library. You start with a <code>get</code> function, but add the <code>@docstring</code> decorator to tell DocStrands that it function uses Google-style docstrings.</p> <pre><code>from docstrands import docstring\n\n@docstring(\"google\")\ndef get(url: str, headers: dict[str, str], params: dict[str, str]) -&gt; str:\n    \"\"\"\n    Makes an HTTP GET request\n\n    Params:\n        url: Path to the resource to request\n        headers: Dictionary of HTTP headers. Keys will be automatically capitalised.\n        params: Dictionary of query parameters which will be URL encoded.\n\n    Returns:\n        The raw HTTP response body as a string.\n    \"\"\"\n</code></pre> <p>Next, you want to write a corresponding <code>post</code> function. The annoying thing is that many of these parameters are exactly the same as on our <code>get</code> function. Here DocStrands solves this by copying the repeated documentation using <code>@get.copy_*</code> functions:</p> <pre><code>@get.copy_params(\"url\", \"headers\")\n@get.copy_returns()\n@docstring(\"google\")\ndef post(url: str, headers: dict[str, str], body: bytes) -&gt; str:\n    \"\"\"\n    Makes an HTTP POST request.\n\n    Params:\n        body: POST body. Text such as JSON will have to be encoded beforehand.\n    \"\"\"\n</code></pre> <p>Finally, you can call <code>help</code> to prove this worked correctly:</p> <pre><code>help(post)\n</code></pre> <pre><code>Help on ParsedFunc in module docstrands.parsed_func:\n\n&lt;function post&gt;\n    Makes an HTTP POST request.\n\n    Args:\n        body: POST body. Text such as JSON will have to be encoded beforehand.\n        url: Path to the resource to request\n        headers: Dictionary of HTTP headers. Keys will be automatically capitalised.\n\n    Returns:\n        : The raw HTTP response body as a string.\n</code></pre>"},{"location":"#type-annotations","title":"Type Annotations","text":"<p>DocStrands supports another approach to re-using documentation: attaching it to types. The above example represents a common case where both functions shared the same return documentation and return type, so we can encode this using Python\u2019s type system:</p> <pre><code>from typing import Annotated\nfrom docstrands import Description\n\nHttpResponse = Annotated[str, Description(\"The raw HTTP response body as a string.\")]\nUrl = Annotated[str, Description(\"Path to the resource to request\")]\nHeaders = Annotated[dict[str, str], Description(\"Dictionary of HTTP headers. Keys will be automatically capitalised.\")]\nParams = Annotated[dict[str, str], Description(\"Dictionary of query parameters which will be URL encoded.\")]\n</code></pre> <p>Then apply them to our new function. Note that we still need to define the function description, and we still need to use the <code>@docstring</code> decorator:</p> <pre><code>@docstring(\"google\")\ndef get(url: Url, headers: Headers, params: Params) -&gt; HttpResponse:\n    \"\"\"\n    Makes an HTTP POST request.\n    \"\"\"\n\nhelp(get)\n</code></pre> <pre><code>Help on ParsedFunc in module docstrands.parsed_func:\n\n&lt;function get&gt;\n    Makes an HTTP POST request.\n\n    Args:\n        url: Path to the resource to request\n        headers: Dictionary of HTTP headers. Keys will be automatically capitalised.\n        params: Dictionary of query parameters which will be URL encoded.\n\n    Returns:\n        : The raw HTTP response body as a string.\n</code></pre> <p>Of course, we can then re-use these parameters with <code>post</code>:</p> <pre><code>Body = Annotated[bytes, Description(\"POST body. Text such as JSON will have to be encoded beforehand.\")]\n\n@docstring(\"google\")\ndef post(url: Url, headers: Headers, body: Body) -&gt; HttpResponse:\n    \"\"\"\n    Makes an HTTP POST request.\n    \"\"\"\n\nhelp(post)\n</code></pre> <pre><code>Help on ParsedFunc in module docstrands.parsed_func:\n\n&lt;function post&gt;\n    Makes an HTTP POST request.\n\n    Args:\n        url: Path to the resource to request\n        headers: Dictionary of HTTP headers. Keys will be automatically capitalised.\n        body: POST body. Text such as JSON will have to be encoded beforehand.\n\n    Returns:\n        : The raw HTTP response body as a string.\n</code></pre> <p>You can even re-use the same types as parameters and return values:</p> <pre><code>@docstring(\"google\")\ndef make_accept_headers() -&gt; Headers:\n    \"\"\"\n    Calculates the the `Accept`, `Accept-Encoding` and `Accept-Language` headers based on the capacity of the HTTP client\n    \"\"\"\n\nhelp(make_accept_headers)\n</code></pre> <pre><code>Help on ParsedFunc in module docstrands.parsed_func:\n\n&lt;function make_accept_headers&gt;\n    Calculates the the `Accept`, `Accept-Encoding` and `Accept-Language` headers based on the capacity of the HTTP client\n\n    Returns:\n        : Dictionary of HTTP headers. Keys will be automatically capitalised.\n</code></pre>"},{"location":"#alternatives","title":"Alternatives","text":"<p>There are other solutions to this problem.</p> <p>We could choose to not use DocStrands at all, but then <code>post</code> would have an incomplete docstring:</p> <p>We could also copy the entire docstring from <code>get</code> and add it to <code>post</code> along with the extra <code>body</code> parameter, but then we would have to keep both docstrings in sync.</p> <p>Finally, it is possible to link between docstrings using cross references (e.g.\u00a0in Sphinx or <code>mkdocstrings</code>). Firstly, this only shows up in your final HTML documentation: standard Python functions like <code>help()</code> don\u2019t understand this. Secondly, it can be frustrating to read documentation that sends you to several other pages just to understand one function. In contrast, DocStrands keeps everything all in one place.</p>"},{"location":"api/","title":"API","text":""},{"location":"api/#docstrands.docstring","title":"<code>docstrands.docstring(style, use_annotations=True)</code>","text":"<p>Parses the docstring of a function so that it can be manipulated.</p> <p>Parameters:</p> Name Type Description Default <code>style</code> <code>DocstringStyle</code> <p>The style of docstring to parse. One of \"rest\" (aka Sphinx), \"google\", \"numpydoc\" or \"epydoc\".</p> required <code>use_annotations</code> <code>bool</code> <p>Whether to apply annotations from the function signature.</p> <code>True</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], ParsedFunc[P, R]]</code> <p>A decorator. When this is applied to a function this decorator will return a <code>ParsedFunc</code> object.</p>"},{"location":"api/#docstrands.ParsedFunc","title":"<code>docstrands.ParsedFunc</code>  <code>dataclass</code>","text":"<p>Contains a function and its parsed docstring, allowing the docstring to be manipulated.</p> <p>In general <code>ParsedFunc</code> impersonates the original function, so it can be used in most places where the original function would be used. A <code>ParsedFunc</code> should only ever be created by the <code>docstring</code> decorator.</p>"},{"location":"api/#docstrands.ParsedFunc.copy_synopsis","title":"<code>copy_synopsis()</code>","text":"<p>Copies the synopsis (first line) from this function to the decorated function.</p>"},{"location":"api/#docstrands.ParsedFunc.copy_description","title":"<code>copy_description()</code>","text":"<p>Copies the description (everything after the synopsis that isn't in a dedicated block) from this function to the decorated function.</p>"},{"location":"api/#docstrands.ParsedFunc.copy_params","title":"<code>copy_params(*params)</code>","text":"<p>Copies parameter documentation from this function to the decorated function.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>str</code> <p>The names of the parameters to copy.</p> <code>()</code>"},{"location":"api/#docstrands.ParsedFunc.copy_returns","title":"<code>copy_returns()</code>","text":"<p>Copies the return documentation from this function to the decorated function.</p>"},{"location":"api/#docstrands.Description","title":"<code>docstrands.Description</code>  <code>dataclass</code>","text":"<p>Allows a description to be attached to any type annotation.</p>"}]}